<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>The Wonderful World of Redis</title>
<meta name="author" content="(jason)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.css"/>

<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/moon.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">The Wonderful World of Redis</h1><h2 class="author">jason</h2><p class="date">Created: 2018-11-21 Wed 22:08</p>
</section>

<section>
<section id="slide-org14275d6">
<h2 id="org14275d6">What is it? A database, a cache, or&#x2026;?!?</h2>
<aside class="notes">
<p>
Best answer: a programmable data structure store!
</p>

</aside>


</section>
<section id="slide-orgad4eeb0">
<h3 id="orgad4eeb0">Acronym:</h3>
<p>
REmote DIctionary Service
</p>
<aside class="notes">
<p>
Sounds like a KV store then&#x2026;
</p>

</aside>
</section>
<section id="slide-orga5540bb">
<h3 id="orga5540bb">redis.io:</h3>
<p>
Redis is an open source, in-memory data structure store, used as a database, cache and message broker.
</p>

</section>
<section id="slide-org5bb7820">
<h3 id="org5bb7820">Seven Databases in Seven Weeks</h3>
<p>
Redis is like grease. It's most often used to lubricate moving parts and keep them working smoothly by reducing friction. Whatever the machinery of your system, it could be improved with a bit poured over it. Sometimes the answer to your problem is simply a judicious use of more Redis.
</p>

</section>
<section id="slide-orgfd3fa6a">
<h3 id="orgfd3fa6a">antirez</h3>
<p>
In may ways Redis resembles more a programming language than a database.  
</p>

</section>
<section id="slide-org4ba71e4">
<h3 id="org4ba71e4">someone on hackernews:</h3>
<p>
IMHO Redis barely registers as a database; it's more of a shared heap that supports snapshotting.
</p>


</section>
</section>
<section>
<section id="slide-org38fc9ec">
<h2 id="org38fc9ec">A potted history, part 1</h2>
<div class="outline-text-2" id="text-org38fc9ec">
</div>
</section>
<section id="slide-org9bbc076">
<h3 id="org9bbc076">in the beginning, memcached</h3>
<ul>
<li>One process per request - CGI-BIN, like PHP</li>
<li>work shared between requests cheaply</li>

</ul>

</section>
<section id="slide-orgabbe202">
<h3 id="orgabbe202">Antirez's usecase - tuple aggregation</h3>
<ul>
<li>prev OS projects: a PL interpreter, and a TCP analyzer</li>
<li>innovations: data structures + replication</li>

</ul>

</section>
</section>
<section>
<section id="slide-org06501f5">
<h2 id="org06501f5">So then, what is it???</h2>
<div class="outline-text-2" id="text-org06501f5">
</div>
</section>
<section id="slide-org1c45851">
<h3 id="org1c45851">Is like a collection library</h3>
<ul>
<li>hosted in a peer process rather than as objects on the heap</li>
<li>instead of clean and simple method dispatch, you've got a tcp protocol</li>

</ul>

</section>
<section id="slide-org3024e40">
<h3 id="org3024e40">Optimized for speed</h3>
<ul>
<li>everything lives in RAM</li>
<li>doesn't do virtual memory - so limited to 'physical' RAM</li>
<li>not optimized for minimum RAM usage either</li>
<li>faster writing than reading (which is strange, isn't it?)</li>
<li>takes pressure off scalability</li>
<li>partitioning ftw</li>

</ul>

</section>
<section id="slide-org62cc6bb">
<h3 id="org62cc6bb">Single threaded</h3>
<ul>
<li>like NodeJS</li>
<li>ensures consistency WITHIN ONE NODE!</li>

</ul>

</section>
<section id="slide-orgd775ef5">
<h3 id="orgd775ef5">Persists to disk asynchronously</h3>
<ul>
<li>snapshots to files in background</li>
<li>also has AOF journal mode</li>
<li>corruption is possible</li>

</ul>

</section>
<section id="slide-orgbe17bc7">
<h3 id="orgbe17bc7">Master -&gt; slave replication</h3>
<ul>
<li>Can only write to single master</li>
<li>Slave is then a back-up if master disappears</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd0632f0">
<h2 id="orgd0632f0">Fun facts</h2>
<ul>
<li>voted most loved database in the Stack Overflow Developer Survey in 2017 and 2018</li>

</ul>


</section>
</section>
<section>
<section id="slide-orgd4bc47e">
<h2 id="orgd4bc47e">Some Redis commands</h2>
<ul>
<li>Syntax of commands is reflected in client libs</li>

</ul>

<p>
CONFIG: sets config at runtime - good to introduce first off, as partially explains Sentinel
</p>

<p>
INCR, DECR: atomic unique id creation, can as global key source, values can then be committed to LIST
LPUSH, LPOP, RPUSH, RPOP&#x2026;: list commands 
above two can be combined to create unique records, with list as an index
<a href="http://oldblog.antirez.com/post/Sorting-in-key-value-data-model.html">http://oldblog.antirez.com/post/Sorting-in-key-value-data-model.html</a> &lt;- see for some patterns
</p>


<p>
MSET, MGET
MULTI: gives you atomicity across commands
</p>


<p>
First demo:
</p>
<ul>
<li>INCR to get unique id</li>
<li>store data to value referenced by unique id</li>
<li>RPUSH to index it</li>
<li>LPOP and then GET to act as consumer</li>
<li>LRANGE etc - show Redis commands docs - like MS docs for collections again</li>
<li>HGET, HSET - dictionaries</li>
<li>very complicated SORT command - show ridiculous signature</li>

</ul>

<p>
Second demo:
</p>
<ul>
<li>MSET, MGET</li>
<li>MULTI&#x2026;EXEC to group things in one atomic transaction</li>
<li>Optimistic watching with WATCH
MULTI doesn't however allow you to read into and reapply local variables - therefore limited</li>

</ul>


<ul>
<li>Pipelining
(printf "PING\r\nPING\r\nPING\r\nPING\r\nPING"; sleep 5) | nc redis1 6379
overhead is hugely reduced; can send thousands of commands like this
like a machine gun
not atomic</li>

</ul>

<p>
Third demo:
</p>
<ul>
<li><i>Redis is a event-driven substrate where it is simple to plug other ideas</i> - Antirez
databases have internal pub/sub; Redis is like database turned inside out</li>
<li>pub/sub - like mini rabbit</li>
<li>mention streams too - a mini kafka</li>

</ul>


<p>
like a database toolkit
</p>


<p>
difference in approach between storing big serialized documents - a document database without any bells and whistles, ie <i>very few features</i>
or - a programmable environment in which to create a bespoke database out of small composable units
</p>

<ul>
<li>it's very fast! 100k ops/s quoted; this makes up for its dubious scalability</li>
<li>pipelining - send commands while others are in flight</li>
<li>simple - replication is simple, unidirectional; flushing to disk is simple
<ul>
<li>doesn't do paging - hard limit of RAM</li>

</ul></li>

</ul>

</section>
<section id="slide-orge96d50d">
<h3 id="orge96d50d">Lua scripting</h3>

</section>
</section>
<section>
<section id="slide-orgc44d638">
<h2 id="orgc44d638">The History of Redis part II</h2>
<div class="outline-text-2" id="text-orgc44d638">
</div>
</section>
<section id="slide-org918ec4d">
<h3 id="org918ec4d">NoSQL hype</h3>
<ul>
<li>turn against integration in db, where SQL has all the perfectly normalised public data of your domain</li>
<li>dovetails with microservices, separation of domain into smaller units that can encapsulate complication locally</li>

</ul>
</section>
<section id="slide-org0237a5a">
<h3 id="org0237a5a">Redis can be used everywhere, for everything!</h3>
<ul>
<li>"Redis is like grease&#x2026;" 7d7w circa 2012</li>
<li>QUOTE PEOPLE EXTOLLING RELIABILITY</li>

</ul>
</section>
<section id="slide-orgc9e56a6">
<h3 id="orgc9e56a6">extension on extension on extension</h3>
<div class="outline-text-3" id="text-orgc9e56a6">
</div>
</section>
<section id="slide-orgb5ca16b">
<h4 id="orgb5ca16b">sentinel (2.8+)</h4>
<p>
a self-regulating quorum of processes
</p>
<ul>
<li>should be in separate failure zones (like the hull of the Titanic: if on)</li>
<li>in practice, they can live alongside dbs, in same 'failure zones' (ie VMs)</li>

</ul>

<p>
decide who the master is
tell clients where to go to (not all clients use this feature though)
</p>

</section>
<section id="slide-orgedb3287">
<h4 id="orgedb3287">cluster (3+)</h4>
<p>
keys are partitioned, live on different nodes - multi-master, like Couchbase, Kafka
again though, who decides which partitions live on which boxes
if there are periods of inconsistency in the layout, then&#x2026;
</p>

</section>
<section id="slide-org405ec7e">
<h4 id="org405ec7e">geolocations (3+)</h4>

</section>
<section id="slide-orgf3709ba">
<h4 id="orgf3709ba">modules (4+)</h4>
<ul>
<li><a href="https://redis.io/modules">https://redis.io/modules</a></li>
<li>search</li>
<li>machine-learning</li>

</ul>

</section>
<section id="slide-org9e6ff78">
<h4 id="org9e6ff78">streams (5+)</h4>
<ul>
<li>mini Kafka</li>

</ul>

</section>
<section id="slide-org5dad6ff">
<h3 id="org5dad6ff">Better and better and better but&#x2026;</h3>
<ul>
<li>Aphyr proves the obvious, 2013: <a href="https://aphyr.com/posts/283-jepsen-redis">https://aphyr.com/posts/283-jepsen-redis</a>
(look at final comment, much more recent)</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3f8f99c">
<h2 id="org3f8f99c">Data loss demo</h2>
<p>
as continuation of rebound
</p>





</section>
</section>
<section>
<section id="slide-orgf34b97e">
<h2 id="orgf34b97e">Sum up positives and negatives</h2>
<div class="outline-text-2" id="text-orgf34b97e">
</div>
</section>
<section id="slide-orgd41026d">
<h3 id="orgd41026d">good</h3>
<ul>
<li>when consistency and durability aren't too important</li>
<li>where data is encapsulated - bad for integration with other apps</li>
<li>therefore, microservices</li>
<li>brill for prototyping</li>

</ul>


</section>
</section>
<section>
<section id="slide-org9e7fa83">
<h2 id="org9e7fa83">Making the best of it</h2>
<ul>
<li>logging and monitoring</li>
<li>data could be asynchronously uploaded to S3?</li>

</ul>


</section>
</section>
<section>
<section id="slide-org7d3cb67">
<h2 id="org7d3cb67">Maintenance tips</h2>
<div class="outline-text-2" id="text-org7d3cb67">
</div>
</section>
<section id="slide-orgd19e26e">
<h3 id="orgd19e26e">first of all, check connections</h3>
</section>
<section id="slide-org3df6b78">
<h3 id="org3df6b78">from the network, from the client, from the server</h3>
</section>
<section id="slide-org29b8833">
<h3 id="org29b8833">tcp connection exhaustion</h3>
</section>
<section id="slide-org885aab0">
<h3 id="org885aab0">logging</h3>
</section>
<section id="slide-org0c5ff51">
<h3 id="org0c5ff51">look at infos on both sentinels and servers</h3>
</section>
<section id="slide-org9d91fd2">
<h3 id="org9d91fd2">check masters and slaves</h3>








</section>
<section id="slide-orgfa1e6d2">
<h3 id="orgfa1e6d2">master-&gt;slave async replication</h3>



</section>
<section id="slide-org6c1c659">
<h3 id="org6c1c659">again, as if it's actually a programming environment</h3>

</section>
<section id="slide-orgd710ff0">
<h3 id="orgd710ff0">single-threaded, good for consistency</h3>
<div class="outline-text-3" id="text-orgd710ff0">
</div>
</section>
<section id="slide-org81da625">
<h4 id="org81da625">kinda like Node</h4>
<div class="outline-text-4" id="text-org81da625">
</div>
<ul class="org-ul">
<li><a id="org3335ef0"></a>concurrent by default, model is simplified by being general<br /></li>
</ul>
</section>
<section id="slide-orgab12091">
<h4 id="orgab12091">the OS is parallelizing loads of stuff underneath</h4>
<p>
it's just being orchestrated by a single thread
</p>

<p>
so, how does this fit with Redis being fast? surely Redis'd be faster and <b>more available</b> if more threads were used
but - it means it just passes over to the OS as fast as possible
</p>

<p>
and how can it be atomic unless it locks keys? well - it must ensure keys are only accessed one at a time
</p>



</section>
<section id="slide-orgfad652c">
<h3 id="orgfad652c">extensions via C (or anything with C bindings)</h3>

</section>
<section id="slide-org68d3933">
<h3 id="org68d3933">Lua scripting ftw</h3>
<div class="outline-text-3" id="text-org68d3933">
</div>
</section>
<section id="slide-org226d127">
<h4 id="org226d127">all is atomic, transactional</h4>
</section>
<section id="slide-org99511d6">
<h4 id="org99511d6">script can live in client code</h4>
</section>
<section id="slide-orgfa7879c">
<h4 id="orgfa7879c">show RedisEntityLogs as example</h4>
</section>
<section id="slide-orgca0c04f">
<h4 id="orgca0c04f">predeclare keys so it fetches em upfront</h4>
</section>
</section>
</div>
</div>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
