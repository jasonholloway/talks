<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>The Wonderful World of Redis</title>
<meta name="author" content="(jason)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./css/reveal.css"/>

<link rel="stylesheet" href="./css/theme/moon.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">The Wonderful World of Redis</h1><h2 class="author">jason</h2><p class="date">Created: 2018-11-25 Sun 11:45</p>
</section>

<section>
<section id="slide-org6166cba">
<h2 id="org6166cba">What is it? A database, a cache, or&#x2026;?!?</h2>
<aside class="notes">
<p>
Best answer: a programmable data structure store!
</p>

</aside>


</section>
<section id="slide-org5ddfc45">
<h3 id="org5ddfc45">Acronym:</h3>
<p>
REmote DIctionary Service
</p>
<aside class="notes">
<p>
Sounds like a KV store then&#x2026;
</p>

</aside>

</section>
<section id="slide-org9fd18b3">
<h3 id="org9fd18b3">redis.io:</h3>
<p>
<i>Redis is an open source, in-memory data structure store, used as a database, cache and message broker</i>
</p>

</section>
<section id="slide-org0846555">
<h3 id="org0846555">Seven Databases in Seven Weeks:</h3>
<p>
<i>Redis is like grease. It's most often used to lubricate moving parts and keep them working smoothly by reducing friction. Whatever the machinery of your system, it could be improved with a bit poured over it. Sometimes the answer to your problem is simply a judicious use of more Redis</i>
</p>
<aside class="notes">
<p>
The culmination of the book
</p>

</aside>

</section>
<section id="slide-orgaf58ebd">
<h3 id="orgaf58ebd">linux-mag:</h3>
<p>
<i>Redis is a form of minimalism</i>
</p>
<aside class="notes">
<p>
How big is the distribution?
1.9mb!
<a href="https://hub.docker.com/r/library/redis/tags/">https://hub.docker.com/r/library/redis/tags/</a>
</p>

</aside>

</section>
<section id="slide-orgbc9ee82">
<h3 id="orgbc9ee82">antirez:</h3>
<p>
<i>In may ways Redis resembles more a programming language than a database</i>
</p>

</section>
<section id="slide-org2431995">
<h3 id="org2431995">someone on hackernews:</h3>
<p>
<i>IMHO Redis barely registers as a database; it's more of a shared heap that supports snapshotting</i>
</p>

</section>
</section>
<section>
<section id="slide-org70e3320">
<h2 id="org70e3320">A potted history, Part I</h2>
<div class="outline-text-2" id="text-org70e3320">
</div>
</section>
<section id="slide-orgd8ab417">
<h3 id="orgd8ab417">in the beginning, memcached + mysql</h3>
<ul>
<li>split betweeen dumb cache and db with query language</li>
<li>one process per request - CGI-BIN, like PHP</li>
<li>work shared between requests cheaply</li>

</ul>
<aside class="notes">
<p>
Used by Google, Facebook&#x2026; most big web operations
works for stable queries and updates of a certain granularity 
very much matches our current usage
small little updates not well served&#x2026;
big leap in durability too from Memcached
</p>

</aside>

</section>
<section id="slide-org334868c">
<h3 id="org334868c">Antirez's usecase - aggregation</h3>
<ul>
<li><i>The project started when Salvatore Sanfilippo, also known as antirez, was developing a real time web log analyzer. After problems in scaling certain specific workloads using traditional database systems&#x2026; etc</i> - Wikipedia</li>
<li>prev OS projects: a PL interpreter, and a TCP analyzer</li>
<li>innovation: data structures + persistence</li>

</ul>

</section>
<section id="slide-org60a225a">
<h3 id="org60a225a">The first version</h3>
<ul>
<li>here: <a href="https://gist.github.com/antirez/6ca04dd191bdb82aad9fb241013e88a8">https://gist.github.com/antirez/6ca04dd191bdb82aad9fb241013e88a8</a></li>
<li><i>A complex system that works is invariably found to have evolved from a simple system that worked</i> - John Gall, Systemantics</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdb418b2">
<h2 id="orgdb418b2">So then, what is it???</h2>
<div class="outline-text-2" id="text-orgdb418b2">
</div>
</section>
<section id="slide-orga60d7db">
<h3 id="orga60d7db">Is like a collection library</h3>
<ul>
<li>hosted in a peer process rather than as objects on the heap</li>
<li>instead of clean and simple method dispatch, you've got a tcp protocol</li>

</ul>

</section>
<section id="slide-org3be41d7">
<h3 id="org3be41d7">Optimized for speed</h3>
<ul>
<li>everything lives in 'physical' RAM</li>
<li>not optimized for minimum RAM usage either</li>
<li>it's very fast! 100k ops/s quoted; this makes up for its dubious scalability</li>
<li>faster writing than reading (which is strange, isn't it?)</li>

</ul>

</section>
<section id="slide-orgd5f7353">
<h3 id="orgd5f7353">Single threaded</h3>
<ul>
<li>like NodeJS</li>
<li>ensures consistency WITHIN ONE NODE!</li>
<li>the OS is parallelizing loads of stuff underneath</li>

</ul>
<aside class="notes">
<p>
so, how does this fit with Redis being fast? surely Redis'd be faster and <b>more available</b> if more threads were used
but - it means it just passes over to the OS as fast as possible
and how can it be atomic unless it locks keys? well - it must ensure keys are only accessed one at a time
</p>

</aside>

</section>
<section id="slide-orgce7fb20">
<h3 id="orgce7fb20">Persists to disk asynchronously</h3>
<ul>
<li>snapshots to files in background</li>
<li>also has AOF journal mode</li>
<li>corruption is possible</li>

</ul>

</section>
<section id="slide-org419a6a7">
<h3 id="org419a6a7">Master -&gt; slave replication</h3>
<ul>
<li>Can only write to single master</li>
<li>Slave is then a back-up if master disappears</li>

</ul>

</section>
</section>
<section>
<section id="slide-org79b2a5d">
<h2 id="org79b2a5d">Fun facts</h2>
<ul>
<li>voted most loved database in the Stack Overflow Developer Survey in 2017 and 2018</li>

</ul>


</section>
</section>
<section>
<section id="slide-org2ab9c4c">
<h2 id="org2ab9c4c">Some Redis commands</h2>
<ul>
<li>Syntax of commands is reflected in client libs</li>

</ul>

<p>
CONFIG: sets config at runtime - good to introduce first off, as partially explains Sentinel
</p>

<p>
INCR, DECR: atomic unique id creation, can as global key source, values can then be committed to LIST
LPUSH, LPOP, RPUSH, RPOP&#x2026;: list commands 
above two can be combined to create unique records, with list as an index
<a href="http://oldblog.antirez.com/post/Sorting-in-key-value-data-model.html">http://oldblog.antirez.com/post/Sorting-in-key-value-data-model.html</a> &lt;- see for some patterns
</p>


<p>
MSET, MGET
MULTI: gives you atomicity across commands
</p>


<p>
First demo:
</p>
<ul>
<li>INCR to get unique id</li>
<li>store data to value referenced by unique id</li>
<li>RPUSH to index it</li>
<li>LPOP and then GET to act as consumer</li>
<li>LRANGE etc - show Redis commands docs - like MS docs for collections again</li>
<li>HGET, HSET - dictionaries</li>
<li>very complicated SORT command - show ridiculous signature</li>

</ul>

<p>
Second demo:
</p>
<ul>
<li>MSET, MGET</li>
<li>MULTI&#x2026;EXEC to group things in one atomic transaction</li>
<li>Optimistic watching with WATCH
MULTI doesn't however allow you to read into and reapply local variables - therefore limited</li>

</ul>


<ul>
<li>Pipelining
(printf "PING\r\nPING\r\nPING\r\nPING\r\nPING"; sleep 5) | nc redis1 6379
overhead is hugely reduced; can send thousands of commands like this
like a machine gun
not atomic</li>

</ul>

<p>
Third demo:
</p>
<ul>
<li><i>Redis is a event-driven substrate where it is simple to plug other ideas</i> - Antirez
databases have internal pub/sub; Redis is like database turned inside out</li>
<li>pub/sub - like mini rabbit</li>
<li>mention streams too - a mini kafka</li>

</ul>


<p>
like a database toolkit
</p>

<p>
difference in approach between storing big serialized documents - a document database without any bells and whistles, ie <i>very few features</i>
or - a programmable environment in which to create a bespoke database out of small composable units
</p>

<ul>
<li>pipelining - send commands while others are in flight</li>
<li>simple - replication is simple, unidirectional; flushing to disk is simple
<ul>
<li>doesn't do paging - hard limit of RAM</li>

</ul></li>

</ul>

</section>
<section id="slide-org4f5609e">
<h3 id="org4f5609e">Lua scripting</h3>
<ul>
<li>all is atomic, transactional</li>
<li>script can live in client code</li>

</ul>
<aside class="notes">
<p>
show RedisEntityLogs as example
predeclare keys so it fetches em upfront
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge1f4a2b">
<h2 id="orge1f4a2b">The History of Redis part II</h2>
<div class="outline-text-2" id="text-orge1f4a2b">
</div>
</section>
<section id="slide-org5aae2aa">
<h3 id="org5aae2aa">NoSQL hype</h3>
<ul>
<li>big turn against integration in db, where SQL has all the perfectly normalised data of your domain</li>
<li>dovetails with microservices</li>
<li>novelty, but not really</li>

</ul>

</section>
<section id="slide-org7093a43">
<h3 id="org7093a43">Redis can be used everywhere, for everything!</h3>
<ul>
<li>"Redis is like grease&#x2026;" 7d7w circa 2012</li>
<li>QUOTE PEOPLE EXTOLLING RELIABILITY</li>

</ul>

</section>
<section id="slide-orgd55852e">
<h3 id="orgd55852e">extension on extension on extension</h3>
<div class="outline-text-3" id="text-orgd55852e">
</div>
</section>
<section id="slide-orge0eebc5">
<h4 id="orge0eebc5">sentinel (2.8+)</h4>
<ul>
<li>a self-regulating quorum of processes, overseeing masters and slaves</li>
<li>should be in separate failure zones</li>
<li>in practice, can live alongside Redis nodes</li>
<li>also tell clients where to go to (not always though - depends on lib)</li>

</ul>

</section>
<section id="slide-org375c40d">
<h4 id="org375c40d">cluster (3+)</h4>
<ul>
<li>keys are auto-partitioned, live on different nodes - multi-master, like Couchbase, Kafka</li>
<li>again though, who decides which partitions live on which boxes? If there are periods of inconsistency in the layout, then&#x2026;</li>

</ul>

</section>
<section id="slide-orgbb26212">
<h4 id="orgbb26212">geolocations (3+)</h4>

</section>
<section id="slide-org0c2d1f5">
<h4 id="org0c2d1f5">modules (4+)</h4>
<ul>
<li><a href="https://redis.io/modules">https://redis.io/modules</a></li>
<li>written in C (or in stuff with C bindings, which is more or less anything)</li>

</ul>

</section>
<section id="slide-orgbc4ea8f">
<h4 id="orgbc4ea8f">streams (5+)</h4>
<ul>
<li>upcoming</li>
<li>mini Kafka</li>

</ul>

</section>
<section id="slide-orgf9ae00d">
<h3 id="orgf9ae00d">Better and better and better but&#x2026;</h3>
<ul>
<li>Aphyr proves the obvious, 2013: <a href="https://aphyr.com/posts/283-jepsen-redis">https://aphyr.com/posts/283-jepsen-redis</a>
(look at final comment, much more recent)</li>

</ul>

</section>
</section>
<section>
<section id="slide-org8dd0ec1">
<h2 id="org8dd0ec1">Data loss demo</h2>
<p>
&#x2026;
</p>


</section>
</section>
<section>
<section id="slide-org10b25b0">
<h2 id="org10b25b0">Strengths and Weaknesses</h2>
<div class="outline-text-2" id="text-org10b25b0">
</div>
</section>
<section id="slide-org00cfe09">
<h3 id="org00cfe09">good</h3>
<ul>
<li>when consistency across nodes and durability aren't too important</li>
<li>where data is encapsulated - bad for integration with other apps</li>
<li>therefore, microservices</li>
<li>brill for prototyping</li>

</ul>

</section>
<section id="slide-org3ce8b1a">
<h3 id="org3ce8b1a">not so good</h3>
<ul>
<li>big documents requiring indexing</li>
<li></li>

<li></li>

</ul>

</section>
</section>
<section>
<section id="slide-org3bd7131">
<h2 id="org3bd7131">Making the best of it</h2>
<ul>
<li>not actually that scalable - use partitioning! As in, split data between clusters</li>
<li>if just being used as KV store of documents, there may be better options</li>

</ul>


</section>
</section>
<section>
<section id="slide-orgbe5e418">
<h2 id="orgbe5e418">Maintenance top tips</h2>
<div class="outline-text-2" id="text-orgbe5e418">
</div>
</section>
<section id="slide-org1e7a4f3">
<h3 id="org1e7a4f3">Check connectivity</h3>
<ul>
<li>use netcat or PuTTY (in raw mode)</li>
<li>from the network, from the client, from the server</li>
<li>beware tcp connection exhaustion!</li>

</ul>

</section>
<section id="slide-org61ff4eb">
<h3 id="org61ff4eb">logging</h3>
<ul>
<li>would tell you about tcp connection exhaustion!</li>
<li>also memory usage</li>
<li>and moving of master</li>

</ul>

</section>
<section id="slide-org5aac9d2">
<h3 id="org5aac9d2">look at infos on both sentinels and servers</h3>
<ul>
<li>check masters and slaves</li>

</ul>
</section>
</section>
</div>
</div>
<script src="./lib/js/head.min.js"></script>
<script src="./js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
