#+OPTIONS: num:nil toc:nil
#+OPTIONS: reveal_history:t
#+Title: The Wonderful World of Redis
  
* What is it? A database, a cache, or...?!?
  
#+BEGIN_NOTES
Best answer: a programmable data structure store!
#+END_NOTES


** Acronym:
REmote DIctionary Service
#+BEGIN_NOTES
Sounds like a KV store then...
#+END_NOTES
** redis.io:
Redis is an open source, in-memory data structure store, used as a database, cache and message broker.

** Seven Databases in Seven Weeks
Redis is like grease. It's most often used to lubricate moving parts and keep them working smoothly by reducing friction. Whatever the machinery of your system, it could be improved with a bit poured over it. Sometimes the answer to your problem is simply a judicious use of more Redis.

** antirez
In may ways Redis resembles more a programming language than a database.  

# ** someone on reddit:
# It hits a nice sweet spot for "nosql" distirbuted data stores between simple K-V stores (like memcached) and map-reduce-ish type full-on document databases (like, I dunno CouchDB or Cassandra or MongoDB or whatever the kids use these days).

** someone on hackernews:
IMHO Redis barely registers as a database; it's more of a shared heap that supports snapshotting.


* A potted history, Part I
** in the beginning, memcached
- One process per request - CGI-BIN, like PHP
- work shared between requests cheaply

** Antirez's usecase - tuple aggregation
- prev OS projects: a PL interpreter, and a TCP analyzer
- innovations: data structures + replication
  
* So then, what is it???

** Is like a collection library
- hosted in a peer process rather than as objects on the heap
- instead of clean and simple method dispatch, you've got a tcp protocol
  
** Optimized for speed
- everything lives in 'physical' RAM 
- not optimized for minimum RAM usage either
- it's very fast! 100k ops/s quoted; this makes up for its dubious scalability
- faster writing than reading (which is strange, isn't it?)
  
** Single threaded
- like NodeJS
- ensures consistency WITHIN ONE NODE!
- the OS is parallelizing loads of stuff underneath
#+BEGIN_NOTES
so, how does this fit with Redis being fast? surely Redis'd be faster and *more available* if more threads were used
but - it means it just passes over to the OS as fast as possible
and how can it be atomic unless it locks keys? well - it must ensure keys are only accessed one at a time
#+END_NOTES
  
** Persists to disk asynchronously
- snapshots to files in background
- also has AOF journal mode
- corruption is possible
  
** Master -> slave replication  
- Can only write to single master
- Slave is then a back-up if master disappears

* Fun facts
- voted most loved database in the Stack Overflow Developer Survey in 2017 and 2018

    
* Some Redis commands
- Syntax of commands is reflected in client libs

CONFIG: sets config at runtime - good to introduce first off, as partially explains Sentinel

INCR, DECR: atomic unique id creation, can as global key source, values can then be committed to LIST
LPUSH, LPOP, RPUSH, RPOP...: list commands 
above two can be combined to create unique records, with list as an index
http://oldblog.antirez.com/post/Sorting-in-key-value-data-model.html <- see for some patterns


MSET, MGET
MULTI: gives you atomicity across commands


First demo:
  - INCR to get unique id
  - store data to value referenced by unique id
  - RPUSH to index it
  - LPOP and then GET to act as consumer
  - LRANGE etc - show Redis commands docs - like MS docs for collections again
  - HGET, HSET - dictionaries
  - very complicated SORT command - show ridiculous signature

Second demo:
  - MSET, MGET
  - MULTI...EXEC to group things in one atomic transaction
  - Optimistic watching with WATCH
    MULTI doesn't however allow you to read into and reapply local variables - therefore limited

    
  - Pipelining
    (printf "PING\r\nPING\r\nPING\r\nPING\r\nPING"; sleep 5) | nc redis1 6379
    overhead is hugely reduced; can send thousands of commands like this
    like a machine gun
    not atomic

Third demo:
  - /Redis is a event-driven substrate where it is simple to plug other ideas/ - Antirez
    databases have internal pub/sub; Redis is like database turned inside out
  - pub/sub - like mini rabbit
  - mention streams too - a mini kafka


like a database toolkit


difference in approach between storing big serialized documents - a document database without any bells and whistles, ie /very few features/
or - a programmable environment in which to create a bespoke database out of small composable units

- pipelining - send commands while others are in flight
- simple - replication is simple, unidirectional; flushing to disk is simple
  - doesn't do paging - hard limit of RAM

** Lua scripting
- all is atomic, transactional
- script can live in client code
#+BEGIN_NOTES
show RedisEntityLogs as example
predeclare keys so it fetches em upfront
#+END_NOTES

* The History of Redis part II
** NoSQL hype
- turn against integration in db, where SQL has all the perfectly normalised public data of your domain
- dovetails with microservices, separation of domain into smaller units that can encapsulate complication locally

** Redis can be used everywhere, for everything!
- "Redis is like grease..." 7d7w circa 2012
- QUOTE PEOPLE EXTOLLING RELIABILITY
  
** extension on extension on extension
*** sentinel (2.8+)
a self-regulating quorum of processes
- should be in separate failure zones
- in practice, they can live alongside dbs, in same 'failure zones' (ie VMs)
- decide who the master is
- also tell clients where to go to (not always though - depends on lib)

*** cluster (3+)
keys are partitioned, live on different nodes - multi-master, like Couchbase, Kafka
again though, who decides which partitions live on which boxes
if there are periods of inconsistency in the layout, then...

*** geolocations (3+)

*** modules (4+)
- https://redis.io/modules
- written in C (or in stuff with C bindings, which is more or less anything)
  
*** streams (5+)
- upcoming
- mini Kafka

** Better and better and better but...
- Aphyr proves the obvious, 2013: https://aphyr.com/posts/283-jepsen-redis
  (look at final comment, much more recent)

* Data loss demo
...


* Strengths and Weaknesses
** good
- when consistency and durability aren't too important
- where data is encapsulated - bad for integration with other apps
- therefore, microservices
- brill for prototyping
  

* Making the best of it
- not actually that scalable - use partitioning!
- data could be asynchronously uploaded to S3?
- if just being used as KV store of documents, there are better options

  
* Maintenance top tips
** Check connectivity
- use netcat or PuTTY (in raw mode)
- from the network, from the client, from the server
- beware tcp connection exhaustion!

** logging
- would tell you about tcp connection exhaustion   
- also memory usage
- and moving of master

** look at infos on both sentinels and servers
- check masters and slaves

