# -**- mode: Org; eval: (reveal-mode 1); -**-
# -**- org-image-actual-width: 500; -**-
#+OPTIONS: toc:nil 
#+REVEAL_INIT_SCRIPT: slideNumber: 'h.v', 
#+REVEAL_INIT_SCRIPT: hash: true, 
#+REVEAL_THEME: sunblind
#+REVEAL_TRANS:None
#+REVEAL_TITLE_SLIDE:
#+REVEAL_EXTRA_CSS:./custom.css
#+REVEAL_HLEVEL:1
#+REVEAL_PLUGINS: (highlight)
#+Title: Deconstructors
#+Description: blah blah blah
* 

#+BEGIN_SRC C#

var thing = new Thing("blah", 123);

#+END_SRC

* Constructors @@html:<span class="mini-exclaim">(woo!)</span>@@
#+BEGIN_SRC C#

var thing = new Thing("blah", 123);

#+END_SRC
#+begin_notes
  that's the end of the talk (joke)

  an args list: the simplest possible construction of values, shoveled in to type constructor
  and you get out, a thing

  the construction does two things, to different degrees

  this is kind of what we get by default, as we're just, as I said, shovelling in this simple list of values into the constructor
  how this type converts these values into the properties and methods it exposes is necessarily up to it, as we've delegated compete control to it
  we're operating entirely on trust
  
  but there's another side to how we expect them to work...

  encapsulation=delegation and packing=trust
#+end_notes

#    it creates an object, an instance of a class
#    it sets up the new instance
#    via the interfaces you know it implements, you can then interact with it
    
#  encapsulates (behaviour)

#  simply structured args list into black hole

#  and it's one way
#       it's the business of the implementing type what it actually does

#  this hides stuff below the contract
#       at this point we can wash our hands of it
  
# packs (data)
#      objects as transparent containers

#  in trad C#, this done by properties, branching etc

#  eg result classes

#  transparency, symmetry

#  decayed, degenerated from OO data+behaviour

#+ATTR_REVEAL: :frag (roll-in roll-in)
- encapsulates
- packs



* ctors /_Encapsulate_/
     #+ATTR_REVEAL: :frag (roll-in roll-in)
   - data is opaquely wrapped
     @@html: <div class="dog-box">@@
     #+begin_src C#

     var dog = new Dog(name: "Bruce", loyalty: 0.37, enthusiasm: 0.76);

     //now parameters are the dog's business...

     #+end_src
     [[./dog1.jpg]]
     @@html: </div>@@

   - and behaviour is exposed
     @@html: <div class="dog-box">@@
      #+begin_src C#

      //our business is limited to the contract

      var stick = dog.FetchStick();

      #+end_src
      [[./dog2.jpg]]
     @@html: </div>@@

* ctors /_Pack_/
     #+ATTR_REVEAL: :frag (roll-in roll-in)
   - data is transparently structured
      #+begin_src C#
      class Dog
      {
        public FetchResult FetchStick()
        {
          return new FetchResult(
            success: true,
            stick: new Stick(variety: Wood.Birch, weight: 0.23)
          );
        }
      }
      #+end_src
   - to be unpacked later
      #+begin_src C#

      var fetched = dog.FetchStick();

      if(fetched.Success)
      {
        Write($"Wow, this stick is {fetched.Stick.Weight} kilogrammes in weight!");
      }

      #+end_src

* Illustrative picture
  [[./dogstick.jpg]]


* C# Syntax
  that's the semantics of it...
  C# syntax has always supported both, but asymetrically

* The rising tide of pack/unpack
 [[./dogsurf.jpg]]

* C#3 Prop-Packing
#+ATTR_REVEAL: :frag roll-in
  - object initializers - set properties directly
    #+begin_src C#
    //caller dictates props
    var meal = new Dinner
    {
      Main = new MeatInGravy(),
      Dessert = new DryBiscuits()
    };
    #+end_src
#+ATTR_REVEAL: :frag roll-in
  - needed by anonymous objects, essential to LINQ
    #+begin_src C#
    return new 
    {
      Decibels = 90,
      Voice = "yapyapyap"
    };
    #+end_src
#+ATTR_REVEAL: :frag roll-in
  - props go in, props come out: symmetry!
    #+begin_src C#
    barks
      .Where(x => x.Voice == "yapyapyap")
      .Select(_ => "could be a poodle?");
    #+end_src
#+begin_notes
  - not about encapsulation!
#+end_notes

* C#7 Type-Unpacking

#+begin_notes
- C#5 had been about async - now we're back to syntax...
- nascent symettry...
- type param goes in, type param comes out
#+end_notes
  
    #+ATTR_REVEAL: :frag roll-in
  - allows us to probe the type used to construct the object
    #+ATTR_REVEAL: :frag roll-in
    #+begin_src C#
      if(pet is Dog dog)
      {
        Beckon(dog.Name);
      }
      else
      {
        //...
      }
    #+end_src

  #+ATTR_REVEAL: :frag roll-in
    #+begin_src C#
      switch(pet)
      {
        case Dog dog:
          Beckon(dog.Name);
          break;

        case Cat cat:
          PutOutSomeFood();
          WaitForAges();
          break;
      }
    #+end_src
#+ATTR_REVEAL: :frag roll-in
  - types go in, types come out: symmetry!

* C#7 Deconstructors
  
#+ATTR_REVEAL: :frag roll-in
  - allow us to unpack both *type* /and/ *arg list*
#+ATTR_REVEAL: :frag roll-in
    #+begin_src C#
      var pets = new[]
      {
        new Dog("Graham", 13),
        new Cat("Tabitha", Foods.Kippers)
      };

      //...

      switch(pet)
      {
        case Dog(var name, _):
          CallOut(name);
          break;

        case Cat(_, var faveFood):
          PutOutSomeFood(faveFood);
          break;
      }
    #+end_src
#+ATTR_REVEAL: :frag roll-in
  - amazing symmetry achieved!

* Dog looking at itself in a mirror
  switch and 'is Type' statements are clear reflections of the syntax used to construct the type in the first place

  Pic of dog here please



* demo of implementing deconstructor...

** 2016
   what happened in 2016?

*** Tuples!
    is like an args list without the type

*** But also introduced new ways of unpacking data

**** type matching (which is unpacking if you squint)

**** pattern-matching of tuples

***** brilliant symmetry of tuples - so simple and so obvious
      like a pivot to a different way of seeing objects - pack/unpack
      crystal clear

**** Deconstructors

***** tuples desugared
      tuples carry the minimum amount of baggage, purest containers
      
***** demo of desconstructed type pattern matching

#+BEGIN_SRC C#
switch(thing) {

  case Thing("blah"):
   break;

  case Thing("blahdy blah"):
   break;

}
#+END_SRC
      

* The present/future

** auto property deconstructuring

*** just syntactical repackaging really

*** but forms symmetrical pair with object initializers
    just like how ctors with an args list tuple get unpacked

** init-only setters

** and finally, records

*** kind of templated data-carrying classes

*** intended to be used with pattern-matching

**** like anon objects v2

*** culmination of data-type story



